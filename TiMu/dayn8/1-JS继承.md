问到的问题会有：

* 类与实例
  * 类的声明--ES5写法和ES6写法
  * 生成实例--new A()
* 类与继承
  * 如何实现继承--基于原型链
  * 继承的几种方式
    - 1，借助构造函数-如何实现，缺点是什么
    - 2，原型继承-------------------
    - 3，构造函数+原型继承-----------
    - 4，构造函数——原型继承的优化点---
具体描述
- 1，在子类的构造函数中调用Parent.call(this),改变了函数执行的上下文，改变了this的指向--导致父类执行属性时都会挂载到子类生成的实例上去。
    缺点：只实现了部分继承，父类的构造函数里面的内容除外，还有原型属性，上面的call并没有将原型链上的内容继承过去
- 2，原型继承的关键--让子类的原型是父类的实例
    Child.prototype = new Parent()
    缺点：原型链中的对象是公用的，数据隔离性不好
- 3，子类的构造函数中也调用call，也让子类的原型是父类的实例
    缺点：1，父类的构造函数执行了两次，不好
    优化1，子类的构造函数中调用call；将子类的原型指向父类的原型
    Child.prototype = Parent.prototype
    存在问题：不能知道实例是由父类创造还是子类创造
        2，在优化1的基础上加--重设子类的构造器
        Child.constructor= Child