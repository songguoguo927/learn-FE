# 排序的目的--组织信息集方便查找

对于给定的信息得先排序再搜索

# 排序算法有很多种
简单排序方法：冒泡排序、选择排序、插入排序、--时间复杂度还是O(n^2)
高级排序算法：归并排序、快速排序，希尔排序、复杂度为O(nlogn)
分布式排序：计数排序、桶排序、基数排序：原始数组中的数据会分发到多个中间结构（桶），再合起来放回
原始数组。
针对排序方法也是，不要一味的追求说哪个排序算法好就用哪一个
每一个算法都有其适应的场景，我们应当结合具体场景，具体数据特点选用不同的排序算法


冒泡排序优化点：
1、len ；
2、j < len-1-i,优化内层循环的比较次数--排好的不用再遍历比较（避免内层循环中所有不必要的比较）
3、
尽管被优化了，但时间复杂度还是O(n^2),不推荐

选择排序：原址比较法，找到数据结构中最小的放到第一位，二小的第二位，依次类推
遍历自身以后的元素，最小的元素和自己调换位置

插入排序: 即->将元素插入到已排序好的数组中
插入排序是最接近生活的排序，因为我们打牌时就差不多是采用的这种排序方法

插入排序比一般的高级排序算法--快排，堆排性能要差，但是还是具有以下优点
1、实现起来简单 理解起来不是很复杂
2、对于较小的数据集而言比较高效
3、相对于其他复杂度为O(n^2)的排序算法-冒泡，选择而言更加快速
4、稳定，及时

到目前为止，已经介绍了三种排序方法，包括冒泡排序、选择排序和插入排序。
这三种排序方法的时间复杂度都为O(n^2)，其中冒泡排序实现最简单，性能最差，选择排序比冒泡排序稍好，
但是还不够，插入排序是这三者中表现最好的，对于小数据集而言效率较高。
这些原因导致三者的实用性并不高，都是最基本的简单排序方法，多用于教学，很难用于实际中，从这节开始介绍更加高级的排序算法

>值得注意的是，JavaScript中的Array.prototype.sort方法没有规定使用哪种排序算法，允许浏览器自定义，FireFox使用的是归并排序法，而Chrome使用的是快速排序法。

# ---高级排序算法
1，归并排序 O(nlogn)  采用**分治法**
分治是通过递归地将问题分解成相同或者类型相关的两个或者多个子问题，直到问题简单到足以解决
然后将子问题的解决方案结合起来，解决原始方案的一种思想

最佳情况：T(n) = O(n)；最差/平均情况：T(n) = O(nlogn)

思想：将原始数组切分成较小的数组，直到每个小数组只有一个位置 
接着将小数组归并成较大的数组，直到最后只有一个排序完毕的大数组

2，快速排序 最佳/平均情况：T(n) = O(nlogn) 最差情况：T(n) = O(n2)
其核心思想也是分而治之，它递归地将大数组分解为小数组，直到数组长度为1，
不过与归并排序的区别在于其重点在于数组的分解，而归并排序的重点在于数组的合并。
快排基本思想：
    通过⼀趟排序将待排记录分隔成独⽴的两部分，
    其中⼀部分记录的关键字均⽐另⼀部分的关键字⼩，
    则可分别对这两部分记录继续进⾏排序，以达到整个序列有序。


快速排序相对于归并排序而言加强了分解部分的逻辑，消除了数组的合并工作
并且不用分配新的内存来存放数组合并结果，所以性能更加优秀，是目前最常用的排序方案。

3，堆排序：堆排序也是一种很高效的排序方法，因为它把数组作为二叉树排序而得名，可以认为是归并排序的改良方案，
它是一种原地排序方法，但是不够稳定，其时间复杂度为O(nlogn)。
如果说快速排序是应用性最强的排序算法，那么我觉得堆排序是趣味性最强的排序方法，非常有意思。


# 搜索算法

线性（顺序）搜索--比较低效
二分（折半）搜索--要求数据结构已排好序