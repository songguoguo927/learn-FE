HEAD: 请求资源的头部信息, 并且这些头部与 HTTP GET 方法请求时返回的一致. 该请求方法的一个使用场景是在下载一个大文件前先获取其大小再决定是否要下载, 以此可以节约带宽资源

数据类型不同：GET只允许 ASCII 字符，而POST无限制
GET无害： 刷新、后退等浏览器操作GET请求是无害的，POST可能重复提交表单
特性不同：GET是安全（这里的安全是指只读特性，就是使用这个方法不会引起服务器状态变化）且幂等（幂等的概念是指同一个请求方法执行多次和仅执行一次的效果完全相同），而POST是非安全非幂等


## PUT 和POST方法的区别是:
PUT方法是幂等的：连续调用一次或者多次的效果相同（无副作用），而POST方法是非幂等的。
>举个例子，我们在开发一个博客系统，当我们要创建一篇文章的时候往往用POST https://www.jianshu.com/articles，这个请求的语义是，在articles的资源集合下创建一篇新的文章，如果我们多次提交这个请求会创建多个文章，这是非幂等的。

>而PUT https://www.jianshu.com/articles/820357430的语义是更新对应文章下的资源（比如修改作者名称等），这个URI指向的就是单一资源，而且是幂等的，比如你把『刘德华』修改成『蔡徐坤』，提交多少次都是修改成『蔡徐坤』


除此之外还有一个区别，通常情况下，PUT的URI指向是具体单一资源，而POST可以指向资源集合。

>ps: 『POST表示创建资源，PUT表示更新资源』这种说法是错误的，两个都能创建资源，根本区别就在于幂等性

PUT和PATCH都是给服务器发送修改资源，有什么区别？

直接覆盖资源的修改方式应该用put，但是你觉得每次都带有这么多无用的信息，那么可以发送PATCH

PUT和PATCH都是更新资源，而PATCH用来对已知资源进行局部更新。
---
HTTP协议原理-实践


## 经典五层模型

应用层--http ftp
    为应用软件提供了很多服务
    构建于TCP协议之上
    屏蔽网络传输相关细节
传输层---TCP/IP UDP
    向用户提供可靠的端到端服务
    向高层屏蔽了下层数据通信的细节
网络层---为数据在结点之间传输创建逻辑链路
数据链路层---在通信的实体间建立数据链路链接
物理层---主要作用：定义物理设备如何传输数据

## HTTP协议发展的历史
HTTP/0.9
    只有一个GET命令
    没有HEADER等描述数据的信息
    服务器发送完毕，就关闭TCP连接

注意：此处连接和http请求是不一样的，在同一个TCP连接中可以发送多个http请求  http/1.1可以这样做
某一个http请求一定是在一个TCP连接中进行发送的

HTTP/1.0
    增加了很多命令-如POST，PUT，HEAD
    增加了status code和header
    多字符集支持，多部分发送，全选，缓存

HTTP/1.1
>基于HTTP1.0,增加了一些功能优化网络连接的过程
    1、增加持久连接--不同于HTTP/0.9 1.0的时候一个http请求完就关闭TCP连接
        有助于提升性能，因为建立一个TCP连接需要3次握手，等等操作，消耗，延迟很高
    2、pipeline
    在同一个TCP连接中可以发送多个http请求，
    但服务端对请求结果的处理返回是按顺序的（串行），造成一个问题，当后面的结果处理的快，还是要等待前一个慢的被处理完，这部分时间的消耗在串行/并行差异就体现出来了---http/2会对这部分进行优化
>HTTP2优化服务端对请求结果的处理返回，串行
    3、增加host和其他一些命令
        物理服务器上的可以同时跑多个软件服务（node服务，java服务），通过host字段判断确定到底是哪个服务；提高物理服务的使用效率
HTTP2
>主要解决一些HTTP1.1中性能底下的部分
    1、所有数据以二进制传输，之前HTTP1.1通过字符串
    数据分片的方式----以帧的方式---》
    2、同一个连接里发送多个请求不再需要按照顺序来
    ---并行，提高传输效率
    3、头信息压缩
    4、推送--服务端可以主动给客户端发送资源内容
    并行传输HTML，CSS，JS文件
    --等提高效率的功能

## TCP连接和HTTP的关系
HTTP只有请求和响应的概念，它们都是数据包，基于建立TCP连接通道进行数据包传输

## HTTP三次握手
三次握手时序图
客户端 发送一个我想创建一个连接的数据包 给服务端
服务端 返回一个 好我给你开了啊
客户端说，好哦我知道你开了

建立三次握手目的：规避网络传输过程中延时导致的一些服务器开销

## URI 包含URL URN
Uniform Resource Identifier /统一资源标志符
    用来唯一标识互联网上的信息资源
Uniform Resource Locator/统一资源定位器
不止只有http开头的可以叫url，比如还有ftp吖
URN永久统一资源定位符

 解决即便搬了网站url仍能定位到--即在资源移动之后还能被找到

 目前还没有非常成熟的使用方案
 ## HTTP报文格式
 请求报文：
 首行: GET /test/hi-here.txt HTTP/1.0-协议版本
 请求头：
    Accept:
    Accept-language:
 空行

 响应报文：
 首行：HTTP/1.0 200 OK--描述状态码的含义
 首部：Content-type:text/plain
 Content-length:19
空行
主体：
Hi

## HTTP方法
用来定义对于资源的操作
GET POST DELETE 。。。
从定义上讲各自有语义
 >语义用来规范，具体操作你不想遵循语义它也不会限制你，建议遵守

## HTTP CODE 状态码

定义服务器请求的处理结果
各个区间的CODE有各自的语义
好的HTTP服务可以通过CODE判断结果

>知道了解就行

## nodejs创建一个最简单的web服务

curl 在命令行使用，帮助我们很好的分析发送请求与请求响应的一个报文
>gitBash自带集成
尝试在gitBash分别输入以下命令观察结果
curl baidu.com
curl www.baidu.com
curl -v www.baidu.com  更详细比上面详细

## CORS跨域请求的限制与解决
1、
response.writeHead(200,{
    'Access-Control-Allow-Origin':'*';
    //*表示任何域名都可以访问这个服务，但是这是不安全的，可以将其设置为特定的域名，也可以根据请求的url来进行判断，然后写入
})

浏览器跨域限制，实际上请求发送了，也响应了，只不过中间被浏览器插了一道，忽略响应内容，并给你报错

2、JSONP

利用link、img、script的src可以进行跨域

## CORS跨域限制以及预请求验证
>保证安全
允许方法 GET HEAD POST
使用其他方法需要预请求

允许Content-Type：
text/plain
multipart/form-data
application/x-www.form-urlencoded
使用其他需要预请求

请求头限制

预请求：对跨域请求的一个预请求，Request Method为OPTIONS
'Access-Control-Allow-Headers':'x-xx',
'Access-Control-Allow-Methods':'DELETE,PUT',
'Access-Control-Max-Age':'1000'
//最长时间：多少秒之内允许跨域请求而不需要进行预请求--即直接发送正式请求

## 缓存 Cache-Control
可缓存性
    public---->http经过的任何地方，都可以进行缓存
    private--->只有发起请求的这个浏览器可以进行缓存
    no-cache-->任何一个结点都不进行缓存
到期
    max-age=<seconds> 设置某一部分的缓存内容多少秒之后过期，过期之后会再次发送请求给服务端请求新的内容
    s-maxage=<seconds> 只有在代理服务器内才会生效，含义类似上面
    max-stale=<seconds> 发起请求方主动带的请求头，代表即便缓存已经过期，只要在max-stale时间内，仍使用缓存的内容，不需要去获取新的内容，一般在浏览器用不到，

重新验证
must-revalidate
proxy-revalidate

其他
no-store
no-transform 禁止代理服务器随意更改压缩返回的内容

>注意，以上只是规范，

12集 7：44